<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CCNx for Android: /var/tmp/plass/ccnx/ccnx-0.8.2/csrc/ccnr/ccnr_proto.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CCNx for Android
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ccnr__proto_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">/var/tmp/plass/ccnx/ccnx-0.8.2/csrc/ccnr/ccnr_proto.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Part of ccnr - CCNx Repository Daemon.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;sys/errno.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;ccn/ccn.h&gt;</code><br/>
<code>#include &lt;ccn/charbuf.h&gt;</code><br/>
<code>#include &lt;ccn/ccn_private.h&gt;</code><br/>
<code>#include &lt;ccn/hashtb.h&gt;</code><br/>
<code>#include &lt;ccn/schedule.h&gt;</code><br/>
<code>#include &lt;ccn/sockaddrutil.h&gt;</code><br/>
<code>#include &lt;ccn/uri.h&gt;</code><br/>
<code>#include &lt;ccn/coding.h&gt;</code><br/>
<code>#include &lt;sync/SyncBase.h&gt;</code><br/>
<code>#include &quot;ccnr_private.h&quot;</code><br/>
<code>#include &quot;ccnr_proto.h&quot;</code><br/>
<code>#include &quot;ccnr_dispatch.h&quot;</code><br/>
<code>#include &quot;ccnr_forwarding.h&quot;</code><br/>
<code>#include &quot;ccnr_init.h&quot;</code><br/>
<code>#include &quot;ccnr_io.h&quot;</code><br/>
<code>#include &quot;ccnr_msg.h&quot;</code><br/>
<code>#include &quot;ccnr_sendq.h&quot;</code><br/>
<code>#include &quot;ccnr_store.h&quot;</code><br/>
<code>#include &quot;ccnr_sync.h&quot;</code><br/>
<code>#include &quot;ccnr_util.h&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5ac86d3f39a8829512117348e9a0fc"></a><!-- doxytag: member="ccnr_proto.c::CCNR_MAX_RETRY" ref="a5c5ac86d3f39a8829512117348e9a0fc" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CCNR_MAX_RETRY</b>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8447991c4b9e95c2aa118c84f83d168"></a><!-- doxytag: member="ccnr_proto.c::ENUMERATION_STATE_TICK_MICROSEC" ref="ab8447991c4b9e95c2aa118c84f83d168" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ENUMERATION_STATE_TICK_MICROSEC</b>&#160;&#160;&#160;1000000</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09cb147151d02fa0624317f58188fd10"></a><!-- doxytag: member="ccnr_proto.c::r_proto_start_write" ref="a09cb147151d02fa0624317f58188fd10" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_start_write</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a430cf7f7832e08280285d33c6f393cb9"></a><!-- doxytag: member="ccnr_proto.c::r_proto_start_write_checked" ref="a430cf7f7832e08280285d33c6f393cb9" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_start_write_checked</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8131ce5b8fa912cef71a628be6aab86b"></a><!-- doxytag: member="ccnr_proto.c::r_proto_begin_enumeration" ref="a8131ce5b8fa912cef71a628be6aab86b" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_begin_enumeration</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cfb05cf8d7caa123adabe59f4cab40c"></a><!-- doxytag: member="ccnr_proto.c::r_proto_continue_enumeration" ref="a3cfb05cf8d7caa123adabe59f4cab40c" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_continue_enumeration</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563189db2b1adcbad622696782ac0440"></a><!-- doxytag: member="ccnr_proto.c::r_proto_bulk_import" ref="a563189db2b1adcbad622696782ac0440" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_bulk_import</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a70fd987b1e084846de60266cd3c017c3">name_comp_equal_prefix</a> (const unsigned char *data, const struct ccn_indexbuf *indexbuf, unsigned int i, const void *buf, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a name component at index i to bytes in buf and return 1 if they are equal in the first length bytes.  <a href="#a70fd987b1e084846de60266cd3c017c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a5c89c02c02862fa60865cfd1b218e"></a><!-- doxytag: member="ccnr_proto.c::r_proto_answer_req" ref="ad2a5c89c02c02862fa60865cfd1b218e" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
PUBLIC enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_answer_req</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee367dfd2b8af67d21bcc3ece4db5b06"></a><!-- doxytag: member="ccnr_proto.c::r_proto_uri_listen" ref="aee367dfd2b8af67d21bcc3ece4db5b06" args="(struct ccnr_handle *ccnr, struct ccn *ccn, const char *uri, ccn_handler p, intptr_t intdata)" -->
PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_uri_listen</b> (struct ccnr_handle *ccnr, struct ccn *ccn, const char *uri, ccn_handler p, intptr_t intdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef394d94d4306260f1355204eadfb12"></a><!-- doxytag: member="ccnr_proto.c::r_proto_init" ref="abef394d94d4306260f1355204eadfb12" args="(struct ccnr_handle *ccnr)" -->
PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_init</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a10e1f366d8ac499821f7dd09b777e9d0">r_proto_activate_policy</a> (struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install the listener for the namespaces that the parsed policy says to serve.  <a href="#a10e1f366d8ac499821f7dd09b777e9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c77667b1ec23d0940fdc72ae10c377"></a><!-- doxytag: member="ccnr_proto.c::r_proto_deactivate_policy" ref="a85c77667b1ec23d0940fdc72ae10c377" args="(struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)" -->
PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a85c77667b1ec23d0940fdc72ae10c377">r_proto_deactivate_policy</a> (struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall the listener for the namespaces that the parsed policy says to serve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b4a35b4d6f63e221a2238c2024ef911"></a><!-- doxytag: member="ccnr_proto.c::r_proto_append_repo_info" ref="a9b4a35b4d6f63e221a2238c2024ef911" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *rinfo, struct ccn_charbuf *names, const char *info)" -->
PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a9b4a35b4d6f63e221a2238c2024ef911">r_proto_append_repo_info</a> (struct ccnr_handle *ccnr, struct ccn_charbuf *rinfo, struct ccn_charbuf *names, const char *info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a charbuf with an encoding of a RepositoryInfo. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08f977612f42a2d4bf2436cf3bc4ff44"></a><!-- doxytag: member="ccnr_proto.c::r_proto_mktemplate" ref="a08f977612f42a2d4bf2436cf3bc4ff44" args="(struct ccnr_expect_content *md, struct ccn_upcall_info *info, int maxsuffix)" -->
static struct ccn_charbuf *&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_mktemplate</b> (struct ccnr_expect_content *md, struct ccn_upcall_info *info, int maxsuffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7022342c3a0054757ce160533385ee77"></a><!-- doxytag: member="ccnr_proto.c::r_proto_expect_content" ref="a7022342c3a0054757ce160533385ee77" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
PUBLIC enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_expect_content</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f1b5ff7ab1d71cf7f773d1e7ed8325"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_update" ref="af2f1b5ff7ab1d71cf7f773d1e7ed8325" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_update</b> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad81888c51edfc8284ca8d402bf365b75"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_complete" ref="ad81888c51edfc8284ca8d402bf365b75" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
static enum ccn_upcall_res&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_complete</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9fa508dbede1f006cfd42bbf0f902a"></a><!-- doxytag: member="ccnr_proto.c::r_proto_check_exclude" ref="aca9fa508dbede1f006cfd42bbf0f902a" args="(struct ccnr_handle *ccnr, struct ccn_upcall_info *info, struct ccn_charbuf *name)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#aca9fa508dbede1f006cfd42bbf0f902a">r_proto_check_exclude</a> (struct ccnr_handle *ccnr, struct ccn_upcall_info *info, struct ccn_charbuf *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the Exclude in the interest described by the info parameter would exclude the full name in name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839f36da4f87d560b0cd5e7c21e7c83b"></a><!-- doxytag: member="ccnr_proto.c::r_proto_finalize_enum_state" ref="a839f36da4f87d560b0cd5e7c21e7c83b" args="(struct hashtb_enumerator *e)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_finalize_enum_state</b> (struct hashtb_enumerator *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc88e81a710eadbd5dd6399962354e4"></a><!-- doxytag: member="ccnr_proto.c::reap_enumerations" ref="a9cc88e81a710eadbd5dd6399962354e4" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a9cc88e81a710eadbd5dd6399962354e4">reap_enumerations</a> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove expired enumeration table entries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e1ba0c455da37d01178bb2345ff3d44"></a><!-- doxytag: member="ccnr_proto.c::reap_enumerations_needed" ref="a1e1ba0c455da37d01178bb2345ff3d44" args="(struct ccnr_handle *ccnr)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>reap_enumerations_needed</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae05c0877f3d803804ee2703f6c6f727"></a><!-- doxytag: member="ccnr_proto.c::r_proto_dump_enums" ref="aae05c0877f3d803804ee2703f6c6f727" args="(struct ccnr_handle *ccnr)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_dump_enums</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03f6adb892890e069ed2de424f5f7471"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_append_basic" ref="a03f6adb892890e069ed2de424f5f7471" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *version, const char *local_name, const char *global_prefix)" -->
PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_append_basic</b> (struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *version, const char *local_name, const char *global_prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04232b8c4b837b754c62910e924d9aaa"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_append_namespace" ref="a04232b8c4b837b754c62910e924d9aaa" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *namespace)" -->
PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_append_namespace</b> (struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *namespace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd5a3888c075ae928fe02b60bba3a29"></a><!-- doxytag: member="ccnr_proto.c::r_proto_parse_policy" ref="a1fd5a3888c075ae928fe02b60bba3a29" args="(struct ccnr_handle *ccnr, const unsigned char *buf, size_t length, struct ccnr_parsed_policy *pp)" -->
PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a1fd5a3888c075ae928fe02b60bba3a29">r_proto_parse_policy</a> (struct ccnr_handle *ccnr, const unsigned char *buf, size_t length, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a ccnb-encoded policy content object and fill in a ccn_parsed_policy structure as the result. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a22346544e87a567a668c08a4f722fe21">r_proto_initiate_key_fetch</a> (struct ccnr_handle *ccnr, const unsigned char *msg, struct ccn_parsed_ContentObject *pco, int use_link, ccnr_cookie a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a key fetch if necessary.  <a href="#a22346544e87a567a668c08a4f722fe21"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Part of ccnr - CCNx Repository Daemon. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a70fd987b1e084846de60266cd3c017c3"></a><!-- doxytag: member="ccnr_proto.c::name_comp_equal_prefix" ref="a70fd987b1e084846de60266cd3c017c3" args="(const unsigned char *data, const struct ccn_indexbuf *indexbuf, unsigned int i, const void *buf, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="ccnr__proto_8c.html#a70fd987b1e084846de60266cd3c017c3">name_comp_equal_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ccn_indexbuf *&#160;</td>
          <td class="paramname"><em>indexbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare a name component at index i to bytes in buf and return 1 if they are equal in the first length bytes. </p>
<p>The name component must contain at least length bytes for this comparison to return equality. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 for equality, 0 for inequality. </dd></dl>

</div>
</div>
<a class="anchor" id="a10e1f366d8ac499821f7dd09b777e9d0"></a><!-- doxytag: member="ccnr_proto.c::r_proto_activate_policy" ref="a10e1f366d8ac499821f7dd09b777e9d0" args="(struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void <a class="el" href="ccnr__proto_8c.html#a10e1f366d8ac499821f7dd09b777e9d0">r_proto_activate_policy</a> </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&#160;</td>
          <td class="paramname"><em>ccnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccnr_parsed_policy *&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install the listener for the namespaces that the parsed policy says to serve. </p>
<p>Normal usage is to deactivate the old policy and then activate the new one </p>

</div>
</div>
<a class="anchor" id="a22346544e87a567a668c08a4f722fe21"></a><!-- doxytag: member="ccnr_proto.c::r_proto_initiate_key_fetch" ref="a22346544e87a567a668c08a4f722fe21" args="(struct ccnr_handle *ccnr, const unsigned char *msg, struct ccn_parsed_ContentObject *pco, int use_link, ccnr_cookie a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ccnr__proto_8c.html#a22346544e87a567a668c08a4f722fe21">r_proto_initiate_key_fetch</a> </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&#160;</td>
          <td class="paramname"><em>ccnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccn_parsed_ContentObject *&#160;</td>
          <td class="paramname"><em>pco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ccnr_cookie&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a key fetch if necessary. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if error or no name, 0 if fetch was issued, 1 if already stored. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="ccnr__proto_8c.html">ccnr_proto.c</a>      </li>

    <li class="footer">Generated on Tue Apr 1 2014 10:51:32 for CCNx for Android by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
