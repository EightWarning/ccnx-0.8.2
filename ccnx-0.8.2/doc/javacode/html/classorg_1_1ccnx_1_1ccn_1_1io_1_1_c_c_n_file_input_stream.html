<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.CCNFileInputStream Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Content-Centric Networking in Java
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">org.ccnx.ccn.io.CCNFileInputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="org::ccnx::ccn::io::CCNFileInputStream" --><!-- doxytag: inherits="org::ccnx::ccn::io::CCNVersionedInputStream,org::ccnx::ccn::io::content::UpdateListener" -->
<p>A CCN input stream that expects content names to be versioned, and streams to have a Header containing file-level metadata about each stream.  
 <a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a57827c947af57aee681fe62c8347448f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#af098141cd5f3bdeeb1b82673a8745836">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#af098141cd5f3bdeeb1b82673a8745836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a97c27d0333346ebc97f40d0cead4afd7">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab6cabfc14759c68cd50211f008142834">publisher</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a97c27d0333346ebc97f40d0cead4afd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aee70ab5deb2ffd48764994f7c9cbe5ba">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#aee70ab5deb2ffd48764994f7c9cbe5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac0253e55d4dac87dd91bd7b4f2609cc5">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab6cabfc14759c68cd50211f008142834">publisher</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#ac0253e55d4dac87dd91bd7b4f2609cc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a2b1d4a8f807e6adeca649221432a5485">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab6cabfc14759c68cd50211f008142834">publisher</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a2b1d4a8f807e6adeca649221432a5485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a48c2f87ac9121e36182bc48bf2338bad">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> startingSegment, EnumSet&lt; <a class="el" href="enumorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream_1_1_flag_types.html">FlagTypes</a> &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved.  <a href="#a48c2f87ac9121e36182bc48bf2338bad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a029e84ecb61d87ac6c0832f08848ab91">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> startingSegment, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, EnumSet&lt; <a class="el" href="enumorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream_1_1_flag_types.html">FlagTypes</a> &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved.  <a href="#a029e84ecb61d87ac6c0832f08848ab91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1e9de63ff5ca69034a00e4fcd2a901b9">hasHeader</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeb8062eebface52c802b509ab4e9c3a1">waitForHeader</a> (Long timeout)  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callers who wish to access the header should call this first; it will wait until the header has been successfully retrieved (if the retrieval has started).  <a href="#aeb8062eebface52c802b509ab4e9c3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1534fd91c2cba6e06512f402c23215ff"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::waitForHeader" ref="a1534fd91c2cba6e06512f402c23215ff" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>waitForHeader</b> ()  throws ContentNotReadyException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html">Header</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a7185356f945852996447c577dd97a9e1">header</a> ()  throws ContentNotReadyException, ContentGoneException, ErrorStateException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the header data if it has been requested.  <a href="#a7185356f945852996447c577dd97a9e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaf6514a029d8e391cfbe6c16e0bbec2"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::getFirstSegment" ref="aeaf6514a029d8e391cfbe6c16e0bbec2" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeaf6514a029d8e391cfbe6c16e0bbec2">getFirstSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Once we have retrieved the first segment of this stream using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html#acc23dd6c55bebe65b5eaaa7034258fc5" title="Implementation of getFirstSegment() that expects segments to be versioned.">CCNVersionedInputStream::getFirstSegment()</a>, initiate header retrieval. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a230a4b96838ba8a37f66b5bcd28a41b1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::skip" ref="a230a4b96838ba8a37f66b5bcd28a41b1" args="(long n)" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>skip</b> (long n)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a50124084c647b4e038ef6e6eb5b3f598">seek</a> (long position)  throws IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek a stream to a specific byte offset from the start.  <a href="#a50124084c647b4e038ef6e6eb5b3f598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#abb4ac8c8739cf28d55f6baec3658bee1">tell</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa1e9dbd04deda5af0bdf5fad9be4481e">length</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1d9f4a53b950a0f04796426a520bd15c">newVersionAvailable</a> (CCNNetworkObject&lt;?&gt; newVersion, boolean wasSave)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification when a new version is available of a given object (the object's data and version information will already have been updated to reflect the new version).  <a href="#a1d9f4a53b950a0f04796426a520bd15c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e0d84b314a3c08693cccc3491cbbb3"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::close" ref="a35e0d84b314a3c08693cccc3491cbbb3" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> ()  throws IOException</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac6dd4335489c463be0dd8521290f2ce8">headerRequested</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a0aa351af0773d67548531f18750de966">requestHeader</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab6cabfc14759c68cd50211f008142834">publisher</a>)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the header in the background.  <a href="#a0aa351af0773d67548531f18750de966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa4ae3877bcb6d43e7e8148c2bc1dc168">segmentCount</a> ()  throws IOException </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa07014a60dbf1bb9c76818a2dea6f4bb"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::_header" ref="aa07014a60dbf1bb9c76818a2dea6f4bb" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa07014a60dbf1bb9c76818a2dea6f4bb">_header</a> = null</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The header information for that object, once we've read it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac84483cc5ef6cc945666b9ccbaab1495"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::_oldHeader" ref="ac84483cc5ef6cc945666b9ccbaab1495" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac84483cc5ef6cc945666b9ccbaab1495">_oldHeader</a> = null</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary backwards-compatibility move... <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A CCN input stream that expects content names to be versioned, and streams to have a Header containing file-level metadata about each stream. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a> for a description of versioning behavior, and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every stream it output...">CCNFileOutputStream</a> for a description of header information. The header is read asynchronously, and may not be available at all until the complete stream has been written (in other words, the publisher typically writes the header last). Stream data can be read normally before the header has been read, and the consumer may opt to ignore the header completely, in which case this acts exactly like a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a>. In fact, a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a> can be used to read data read by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every stream it output...">CCNFileOutputStream</a> (except for the header). Using a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html" title="A CCN input stream that expects content names to be versioned, and streams to have a Header containin...">CCNFileInputStream</a> to read something not written by a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every stream it output...">CCNFileOutputStream</a> or one of its subclasses (in other words, something without a header) will still try to retrieve the (nonexistent) header in the background, but will not cause an error unless someone tries to access the header data itself.</p>
<p>Headers are named according to definitions in the SegmentationProfile. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a57827c947af57aee681fe62c8347448f"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a57827c947af57aee681fe62c8347448f" args="(ContentName baseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em></td><td>)</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af098141cd5f3bdeeb1b82673a8745836"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="af098141cd5f3bdeeb1b82673a8745836" args="(ContentName baseName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97c27d0333346ebc97f40d0cead4afd7"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a97c27d0333346ebc97f40d0cead4afd7" args="(ContentName baseName, PublisherPublicKeyDigest publisher, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td class="paramname">publisher</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee70ab5deb2ffd48764994f7c9cbe5ba"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="aee70ab5deb2ffd48764994f7c9cbe5ba" args="(ContentName baseName, Long startingSegmentNumber, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&#160;</td>
          <td class="paramname"><em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td class="paramname">startingSegmentNumber</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile::baseSegment()</a>. </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0253e55d4dac87dd91bd7b4f2609cc5"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="ac0253e55d4dac87dd91bd7b4f2609cc5" args="(ContentName baseName, Long startingSegmentNumber, PublisherPublicKeyDigest publisher, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&#160;</td>
          <td class="paramname"><em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td class="paramname">startingSegmentNumber</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile::baseSegment()</a>. </td></tr>
    <tr><td class="paramname">publisher</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b1d4a8f807e6adeca649221432a5485"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a2b1d4a8f807e6adeca649221432a5485" args="(ContentName baseName, Long startingSegmentNumber, PublisherPublicKeyDigest publisher, ContentKeys keys, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&#160;</td>
          <td class="paramname"><em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td class="paramname">startingSegmentNumber</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile::baseSegment()</a>. </td></tr>
    <tr><td class="paramname">publisher</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td class="paramname">keys</td><td>The keys to use to decrypt this content. If null, assumes content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48c2f87ac9121e36182bc48bf2338bad"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a48c2f87ac9121e36182bc48bf2338bad" args="(ContentObject startingSegment, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&#160;</td>
          <td class="paramname"><em>startingSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; <a class="el" href="enumorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream_1_1_flag_types.html">FlagTypes</a> &gt;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startingSegment</td><td>The first segment to read from. If this is not the first segment of the stream, reading will begin from this point. We assume that the signature on this segment was verified by our caller. </td></tr>
    <tr><td class="paramname">flags</td><td>any stream flags that must be set to handle even this first block (otherwise they can be set with setFlags prior to read). Can be null. </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a029e84ecb61d87ac6c0832f08848ab91"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a029e84ecb61d87ac6c0832f08848ab91" args="(ContentObject startingSegment, ContentKeys keys, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&#160;</td>
          <td class="paramname"><em>startingSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; <a class="el" href="enumorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream_1_1_flag_types.html">FlagTypes</a> &gt;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startingSegment</td><td>The first segment to read from. If this is not the first segment of the stream, reading will begin from this point. We assume that the signature on this segment was verified by our caller. </td></tr>
    <tr><td class="paramname">keys</td><td>The keys to use to decrypt this content. Null if content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td class="paramname">flags</td><td>any stream flags that must be set to handle even this first block (otherwise they can be set with setFlags prior to read). Can be null. </td></tr>
    <tr><td class="paramname">handle</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle::getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1e9de63ff5ca69034a00e4fcd2a901b9"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::hasHeader" ref="a1e9de63ff5ca69034a00e4fcd2a901b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1e9de63ff5ca69034a00e4fcd2a901b9">org.ccnx.ccn.io.CCNFileInputStream.hasHeader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we have retrieved the header. </dd></dl>

</div>
</div>
<a class="anchor" id="a7185356f945852996447c577dd97a9e1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::header" ref="a7185356f945852996447c577dd97a9e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html">Header</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a7185356f945852996447c577dd97a9e1">org.ccnx.ccn.io.CCNFileInputStream.header</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_error_state_exception.html">ErrorStateException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accesses the header data if it has been requested. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Header for this stream. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ContentNotReadyException</td><td>if we have not retrieved the header yet, or it hasn't been requested. </td></tr>
    <tr><td class="paramname">ContentGoneException</td><td>if the header has been deleted. </td></tr>
    <tr><td class="paramname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_error_state_exception.html" title="Exception to throw when we are asked to pull data from a network object or stream that is already in ...">ErrorStateException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6dd4335489c463be0dd8521290f2ce8"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::headerRequested" ref="ac6dd4335489c463be0dd8521290f2ce8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac6dd4335489c463be0dd8521290f2ce8">org.ccnx.ccn.io.CCNFileInputStream.headerRequested</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we have started the header retrieval process. To begin the process, we must first know what version of the content we are reading. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e9dbd04deda5af0bdf5fad9be4481e"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::length" ref="aa1e9dbd04deda5af0bdf5fad9be4481e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa1e9dbd04deda5af0bdf5fad9be4481e">org.ccnx.ccn.io.CCNFileInputStream.length</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Total length of the stream, if known, otherwise -1. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#afd70027a5a1bb181420753b8168ac0ca">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a1d9f4a53b950a0f04796426a520bd15c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::newVersionAvailable" ref="a1d9f4a53b950a0f04796426a520bd15c" args="(CCNNetworkObject&lt;?&gt; newVersion, boolean wasSave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1d9f4a53b950a0f04796426a520bd15c">org.ccnx.ccn.io.CCNFileInputStream.newVersionAvailable</a> </td>
          <td>(</td>
          <td class="paramtype">CCNNetworkObject&lt;?&gt;&#160;</td>
          <td class="paramname"><em>newVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>wasSave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notification when a new version is available of a given object (the object's data and version information will already have been updated to reflect the new version). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newVersion</td><td>The newly updated object. </td></tr>
    <tr><td class="paramname">wasSave</td><td>If true, someone called save() on this particular object, if false, the object received new data from the network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_update_listener.html#a459fc1563a2754b5212ec1205c8dae14">org.ccnx.ccn.io.content.UpdateListener</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa351af0773d67548531f18750de966"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::requestHeader" ref="a0aa351af0773d67548531f18750de966" args="(ContentName baseName, PublisherPublicKeyDigest publisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a0aa351af0773d67548531f18750de966">org.ccnx.ccn.io.CCNFileInputStream.requestHeader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request the header in the background. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>name of the content, including the version, from which the header name will be derived. </td></tr>
    <tr><td class="paramname">publisher</td><td>expected publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>If the header cannot be retrieved. </td></tr>
    <tr><td class="paramname">ContentDecodingException</td><td>If the header cannot be decoded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50124084c647b4e038ef6e6eb5b3f598"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::seek" ref="a50124084c647b4e038ef6e6eb5b3f598" args="(long position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a50124084c647b4e038ef6e6eb5b3f598">org.ccnx.ccn.io.CCNFileInputStream.seek</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek a stream to a specific byte offset from the start. </p>
<p>Tries to avoid retrieving extra segments. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a098c5a243c20596540663f3be8a9dd79">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="aa4ae3877bcb6d43e7e8148c2bc1dc168"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::segmentCount" ref="aa4ae3877bcb6d43e7e8148c2bc1dc168" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa4ae3877bcb6d43e7e8148c2bc1dc168">org.ccnx.ccn.io.CCNFileInputStream.segmentCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently returns 0. Can be optionally overridden by subclasses. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a15cad7928184959904d201cbce45fe69">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="abb4ac8c8739cf28d55f6baec3658bee1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::tell" ref="abb4ac8c8739cf28d55f6baec3658bee1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#abb4ac8c8739cf28d55f6baec3658bee1">org.ccnx.ccn.io.CCNFileInputStream.tell</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns position in byte offset. For <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html" title="This abstract class is the superclass of all classes representing an input stream of bytes segmented ...">CCNAbstractInputStream</a>, provide an inadequate base implementation that returns the offset into the current segment (not the stream as a whole). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6798b2f7be10f611e4ab020afdca1dc7">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8062eebface52c802b509ab4e9c3a1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::waitForHeader" ref="aeb8062eebface52c802b509ab4e9c3a1" args="(Long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeb8062eebface52c802b509ab4e9c3a1">org.ccnx.ccn.io.CCNFileInputStream.waitForHeader</a> </td>
          <td>(</td>
          <td class="paramtype">Long&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callers who wish to access the header should call this first; it will wait until the header has been successfully retrieved (if the retrieval has started). </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ContentNotReadyException</td><td>if we have not requested the header yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/org/ccnx/ccn/io/CCNFileInputStream.java</li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>org</b>      </li>
      <li class="navelem"><b>ccnx</b>      </li>
      <li class="navelem"><b>ccn</b>      </li>
      <li class="navelem"><b>io</b>      </li>
      <li class="navelem"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html">CCNFileInputStream</a>      </li>

    <li class="footer">Generated on Tue Apr 1 2014 10:51:29 for Content-Centric Networking in Java by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
