<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.impl.sync.SliceComparator Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Content-Centric Networking in Java
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">org.ccnx.ccn.impl.sync.SliceComparator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="org::ccnx::ccn::impl::sync::SliceComparator" --><!-- doxytag: inherits="Runnable,Comparable" -->
<p>This class is the main comparator used to decode sync items and determine what has newly been seen that has not already been seen.  
 <a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator_1_1_node_fetch_handler.html">NodeFetchHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get back data from a node fetch request.  <a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator_1_1_node_fetch_handler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="enumorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator_1_1_sync_compare_state.html">SyncCompareState</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a7e9e48b53599515516f59ffd5bbe478d">SliceComparator</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html">SliceComparator</a> leadComparator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html">SyncNodeCache</a> snc, <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a> callback, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_config_slice.html">ConfigSlice</a> slice, byte[] startHash, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> startName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a comparison on a slice which will call back each registered "callback" each time a previously unseen name is seen.  <a href="#a7e9e48b53599515516f59ffd5bbe478d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a584ec857c066726ccdd677e420f604ff">addPending</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> ste)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new data into the system - either a hash which must be looked up or node data which can be directly decoded.  <a href="#a584ec857c066726ccdd677e420f604ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a76cb0668acf0c3db4e7dc5dc3384d3af">addPendingContent</a> (byte[] data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add pending hash from seen data.  <a href="#a76cb0668acf0c3db4e7dc5dc3384d3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a8c7480f4dbcc085848dd2e1916c0bb77">addCallback</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a> callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch a callback onto a comparator.  <a href="#a8c7480f4dbcc085848dd2e1916c0bb77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized ArrayList<br class="typebreak"/>
&lt; <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a9bd081ac95badb61021e413f5cf461f2">getCallbacks</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callbacks WARNING - any outside changes to this must be synced.  <a href="#a9bd081ac95badb61021e413f5cf461f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#acdbc63c850d8d61e25101f557180ff85">removeCallback</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a> callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback associated with this comparator.  <a href="#acdbc63c850d8d61e25101f557180ff85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a3bca3b90b50c2e084542daca64bdc6a8">shutdownIfUseless</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Useless" is defined as having no callbacks registered  <a href="#a3bca3b90b50c2e084542daca64bdc6a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d7e03d4a1157b3f46fee348f3fd8312"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::isShutdown" ref="a1d7e03d4a1157b3f46fee348f3fd8312" args="()" -->
boolean&#160;</td><td class="memItemRight" valign="bottom"><b>isShutdown</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b643c6adfe7aaa3f852630827a0e6cb"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getHandle" ref="a1b643c6adfe7aaa3f852630827a0e6cb" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getHandle</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be349405b26604a15a6cd8fb53ca031"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getHashCache" ref="a4be349405b26604a15a6cd8fb53ca031" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_hash_cache.html">SyncHashCache</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getHashCache</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d8e205a5eb99547e3fd8886aef9a48"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getNodeCache" ref="a31d8e205a5eb99547e3fd8886aef9a48" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html">SyncNodeCache</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeCache</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a3b8b58dcf84560b7f1cfa346f60144"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::setTimeout" ref="a1a3b8b58dcf84560b7f1cfa346f60144" args="(long timeout)" -->
synchronized void&#160;</td><td class="memItemRight" valign="bottom"><b>setTimeout</b> (long timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#aa824713a6aedddd0e41d1a4c9ee94801">getCurrentRoot</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Must return a copy because the STE can be used in a different comparator.  <a href="#aa824713a6aedddd0e41d1a4c9ee94801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42ea0bac93f7105029ee302aaea422e0"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::kickCompare" ref="a42ea0bac93f7105029ee302aaea422e0" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a42ea0bac93f7105029ee302aaea422e0">kickCompare</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start compare process if not already running. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8524947b59517ecdc07ee1362940714"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::comparing" ref="af8524947b59517ecdc07ee1362940714" args="()" -->
synchronized boolean&#160;</td><td class="memItemRight" valign="bottom"><b>comparing</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#ac30dfa3d06b2f26cb549242396b684e2">run</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate thread for running comparisons.  <a href="#ac30dfa3d06b2f26cb549242396b684e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9335d09490398ac1706d4d502ae75d91"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::compareTo" ref="a9335d09490398ac1706d4d502ae75d91" args="(SliceComparator o)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a9335d09490398ac1706d4d502ae75d91">compareTo</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html">SliceComparator</a> o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To allow use in Concurrent maps which require <a class="el" href="class_comparable.html">Comparable</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ae3339f8297e7879d61087dc8915931"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::_executor" ref="a6ae3339f8297e7879d61087dc8915931" args="" -->
ScheduledThreadPoolExecutor&#160;</td><td class="memItemRight" valign="bottom"><b>_executor</b> = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3babc3481c73295559cf9ab7d7f84477"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::COMPARE_INTERVAL" ref="a3babc3481c73295559cf9ab7d7f84477" args="" -->
final int&#160;</td><td class="memItemRight" valign="bottom"><b>COMPARE_INTERVAL</b> = 100</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f2b3dbcb8440f8e3c785c1aa3b66f06"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::DECODER_SIZE" ref="a1f2b3dbcb8440f8e3c785c1aa3b66f06" args="" -->
static final int&#160;</td><td class="memItemRight" valign="bottom"><b>DECODER_SIZE</b> = 756</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a3e800b597dbd09f1c65c6aa308560d48">getPending</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best (highest hash) pending entry for a new comparison.  <a href="#a3e800b597dbd09f1c65c6aa308560d48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a8094fbede3d53e4f270f18950799e0a3">getPendingContent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending content is used when we don't know the hash ahead of time - we can only find it by decoding the content.  <a href="#a8094fbede3d53e4f270f18950799e0a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac743b2e6e488b4c06d71f0324d9709"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::checkNextRound" ref="a5ac743b2e6e488b4c06d71f0324d9709" args="()" -->
synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a5ac743b2e6e488b4c06d71f0324d9709">checkNextRound</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart compare process if its not currently in process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab51abb23298dab1b97847b8ca290d02"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::push" ref="aab51abb23298dab1b97847b8ca290d02" args="(SyncTreeEntry srt, Deque&lt; SyncTreeEntry &gt; stack)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>push</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> srt, Deque&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> &gt; stack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a923fdbdb686861daa0b7127efca24398"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::pop" ref="a923fdbdb686861daa0b7127efca24398" args="(Deque&lt; SyncTreeEntry &gt; stack)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pop</b> (Deque&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> &gt; stack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a726a88e01c9dd742b499c164ccc13485"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getHead" ref="a726a88e01c9dd742b499c164ccc13485" args="(Deque&lt; SyncTreeEntry &gt; stack)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getHead</b> (Deque&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> &gt; stack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#ae85c4c1395e3ea909469c453054436ce">nextRound</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new round of comparison.  <a href="#ae85c4c1395e3ea909469c453054436ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a1ec34de5b21db9220d2daa01fc8e580e">updateCurrent</a> ()  throws SyncException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">We keep a running tree of what we already have in "X".  <a href="#a1ec34de5b21db9220d2daa01fc8e580e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class is the main comparator used to decode sync items and determine what has newly been seen that has not already been seen. </p>
<p>The algorithm is based on the similar one implemented in the C code.</p>
<p>The basic idea is that we do a continuous compare of hash trees arriving from sync. The first hash tree of course will contain all names that have not been seen before. After that we do a double tree walk of the the "last" (labeled 'X') and the new (labeled 'Y') hash trees. As we walk we compare the trees to find nodes that are as yet unseen and report the results (a ContentName) to the user via a callback. Every hash that has been walked through in the 'Y' phase is marked 'covered' so that we can immediately discard any exactly matching hashes we see in the future. Since incoming hashes can be disjoint, at the start of each new comparison, we also update the X tree to contain any new items which were seen on the last pass. This can often cause the construction of new hashes which are not the same as hashes we have seen from the network.</p>
<p>New hashes seen from the network are fed into the system via the "addPending" methods.</p>
<p>Note: We purposely don't decode SyncNodeComposites in handlers since they are big and slow and we risk timing out the handler by doing so.</p>
<p>Note about synchronization: This class is multi-threaded and contains many class global fields which at first glance would seem to need synchronization. However care has been taken to insure that the "run" loop can not be run more than once simultaneously and that all unsynchronized global fields are only referenced from the run routine or by internal methods called only by it so that synchronization is in fact unnecessary. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e9e48b53599515516f59ffd5bbe478d"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::SliceComparator" ref="a7e9e48b53599515516f59ffd5bbe478d" args="(SliceComparator leadComparator, SyncNodeCache snc, CCNSyncHandler callback, ConfigSlice slice, byte[] startHash, ContentName startName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a7e9e48b53599515516f59ffd5bbe478d">org.ccnx.ccn.impl.sync.SliceComparator.SliceComparator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html">SliceComparator</a>&#160;</td>
          <td class="paramname"><em>leadComparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html">SyncNodeCache</a>&#160;</td>
          <td class="paramname"><em>snc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_config_slice.html">ConfigSlice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>startHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>startName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a comparison on a slice which will call back each registered "callback" each time a previously unseen name is seen. </p>
<p>Note that with the 0 length hash we can only base the "start" of our reporting on the hash we get back from the root advise request. If there is more than one repository reporting and the first answer we get is disjoint from some other answer, we may receive names later that are earlier than the "start" so this is just a best attempt.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">leadComparator</td><td>- the lead comparator on this slice. If we have multiple comparators for a slice, we only need to check differences for one round after the first one starts (which becomes the lead comparator), then the callbacks can just be reregistered with the lead comparator </td></tr>
    <tr><td class="paramname">snc</td><td>global node cache to use </td></tr>
    <tr><td class="paramname">callback</td><td>callback to user code </td></tr>
    <tr><td class="paramname">slice</td><td>corresponding slice </td></tr>
    <tr><td class="paramname">startHash</td><td>if null, report all names seen, if 0 length attempt to not report anything before this was called, if contains a hash, report all names that are not in that hash. </td></tr>
    <tr><td class="paramname">startName</td><td>report all names seen after we see this name </td></tr>
    <tr><td class="paramname">handle</td><td>the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> to use</td></tr>
  </table>
  </dd>
</dl>
<p>TODO for now we need to allow a null slice for testing. This should maybe be refactored somehow </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8c7480f4dbcc085848dd2e1916c0bb77"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::addCallback" ref="a8c7480f4dbcc085848dd2e1916c0bb77" args="(CCNSyncHandler callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a8c7480f4dbcc085848dd2e1916c0bb77">org.ccnx.ccn.impl.sync.SliceComparator.addCallback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Switch a callback onto a comparator. </p>
<p>The hash is to avoid adding the callback too early - we don't want to start calling back if we haven't completed working on a hash already done by the callback. Possibly this isn't necessary as the checks on whether the comparator has been kicked make this unlikely I think.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">hash</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a584ec857c066726ccdd677e420f604ff"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::addPending" ref="a584ec857c066726ccdd677e420f604ff" args="(SyncTreeEntry ste)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a584ec857c066726ccdd677e420f604ff">org.ccnx.ccn.impl.sync.SliceComparator.addPending</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a>&#160;</td>
          <td class="paramname"><em>ste</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add new data into the system - either a hash which must be looked up or node data which can be directly decoded. </p>
<p>These will be used to start a new hash tree for the next compare when the current one has completed.</p>
<p>These will normally be called by handlers in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_protocol_based_sync_monitor.html" title="Snoops on the sync protocol to report new files seen by sync on a slice to a registered handler To do...">ProtocolBasedSyncMonitor</a> so it is therefore handler code (so we should not decode anything here).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ste</td><td>entry for new hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a76cb0668acf0c3db4e7dc5dc3384d3af"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::addPendingContent" ref="a76cb0668acf0c3db4e7dc5dc3384d3af" args="(byte[] data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a76cb0668acf0c3db4e7dc5dc3384d3af">org.ccnx.ccn.impl.sync.SliceComparator.addPendingContent</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add pending hash from seen data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data seen. The hash isn't known until we decode the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bd081ac95badb61021e413f5cf461f2"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getCallbacks" ref="a9bd081ac95badb61021e413f5cf461f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized ArrayList&lt;<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a>&gt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a9bd081ac95badb61021e413f5cf461f2">org.ccnx.ccn.impl.sync.SliceComparator.getCallbacks</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the callbacks WARNING - any outside changes to this must be synced. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa824713a6aedddd0e41d1a4c9ee94801"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getCurrentRoot" ref="aa824713a6aedddd0e41d1a4c9ee94801" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#aa824713a6aedddd0e41d1a4c9ee94801">org.ccnx.ccn.impl.sync.SliceComparator.getCurrentRoot</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Must return a copy because the STE can be used in a different comparator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a3e800b597dbd09f1c65c6aa308560d48"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getPending" ref="a3e800b597dbd09f1c65c6aa308560d48" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_tree_entry.html">SyncTreeEntry</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a3e800b597dbd09f1c65c6aa308560d48">org.ccnx.ccn.impl.sync.SliceComparator.getPending</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the best (highest hash) pending entry for a new comparison. </p>
<p>Also prunes duplicates out of the tree.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8094fbede3d53e4f270f18950799e0a3"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::getPendingContent" ref="a8094fbede3d53e4f270f18950799e0a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a8094fbede3d53e4f270f18950799e0a3">org.ccnx.ccn.impl.sync.SliceComparator.getPendingContent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pending content is used when we don't know the hash ahead of time - we can only find it by decoding the content. </p>
<p>We store and retrieve it because we don't want to do the decoding in a handler.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the raw content </dd></dl>

</div>
</div>
<a class="anchor" id="ae85c4c1395e3ea909469c453054436ce"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::nextRound" ref="ae85c4c1395e3ea909469c453054436ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#ae85c4c1395e3ea909469c453054436ce">org.ccnx.ccn.impl.sync.SliceComparator.nextRound</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a new round of comparison. </p>
<p>_currentRoot holds the head of the last Y hash tree so we move it to X (_current) here. </p>

</div>
</div>
<a class="anchor" id="acdbc63c850d8d61e25101f557180ff85"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::removeCallback" ref="acdbc63c850d8d61e25101f557180ff85" args="(CCNSyncHandler callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#acdbc63c850d8d61e25101f557180ff85">org.ccnx.ccn.impl.sync.SliceComparator.removeCallback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_sync_handler.html">CCNSyncHandler</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a callback associated with this comparator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the callback </dd></dl>

</div>
</div>
<a class="anchor" id="ac30dfa3d06b2f26cb549242396b684e2"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::run" ref="ac30dfa3d06b2f26cb549242396b684e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#ac30dfa3d06b2f26cb549242396b684e2">org.ccnx.ccn.impl.sync.SliceComparator.run</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Separate thread for running comparisons. </p>
<p>We run until we can't do anything anymore, then rely on "kickCompare" to restart the thread. It uses a state machine to figure out where it left off and where to start back in again. </p>

</div>
</div>
<a class="anchor" id="a3bca3b90b50c2e084542daca64bdc6a8"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::shutdownIfUseless" ref="a3bca3b90b50c2e084542daca64bdc6a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a3bca3b90b50c2e084542daca64bdc6a8">org.ccnx.ccn.impl.sync.SliceComparator.shutdownIfUseless</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Useless" is defined as having no callbacks registered </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1ec34de5b21db9220d2daa01fc8e580e"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SliceComparator::updateCurrent" ref="a1ec34de5b21db9220d2daa01fc8e580e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html#a1ec34de5b21db9220d2daa01fc8e580e">org.ccnx.ccn.impl.sync.SliceComparator.updateCurrent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_exception.html">SyncException</a> <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We keep a running tree of what we already have in "X". </p>
<p>Update it here to reflect what we got on the last round. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_exception.html">SyncException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/org/ccnx/ccn/impl/sync/SliceComparator.java</li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>org</b>      </li>
      <li class="navelem"><b>ccnx</b>      </li>
      <li class="navelem"><b>ccn</b>      </li>
      <li class="navelem"><a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1impl.html">impl</a>      </li>
      <li class="navelem"><b>sync</b>      </li>
      <li class="navelem"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_slice_comparator.html">SliceComparator</a>      </li>

    <li class="footer">Generated on Tue Apr 1 2014 10:51:29 for Content-Centric Networking in Java by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
