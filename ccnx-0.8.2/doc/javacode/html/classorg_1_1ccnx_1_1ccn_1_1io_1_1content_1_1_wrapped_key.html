<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.content.WrappedKey Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Content-Centric Networking in Java
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pac-static-methods">Static Package Functions</a> &#124;
<a href="#pac-attribs">Package Attributes</a>  </div>
  <div class="headertitle">
<div class="title">org.ccnx.ccn.io.content.WrappedKey Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="org::ccnx::ccn::io::content::WrappedKey" --><!-- doxytag: inherits="org::ccnx::ccn::impl::encoding::GenericXMLEncodable,org::ccnx::ccn::impl::encoding::XMLEncodable" -->
<p>A representation of wrapped (encrypted) keys for strorage in CCN.  
 <a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A CCNNetworkObject wrapper around <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>, used for easily saving and retrieving versioned WrappedKeys to CCN.  <a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a8a7bdec10b52b3b73a6608f4f2dfc56f">WrappedKey</a> (byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a>, byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">encryptedKey</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>.  <a href="#a8a7bdec10b52b3b73a6608f4f2dfc56f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a82a56fa01d0bf73c6b3cf621a676769f">WrappedKey</a> (byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acf42abcf7fd28812960a3305d5ee9345">label</a>, byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">encryptedKey</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>.  <a href="#a82a56fa01d0bf73c6b3cf621a676769f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7e3f51eeab08a59a587f4752d211a14c">WrappedKey</a> (byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ac9fa1a3a4042ea554895e3b0e4a55714">wrapAlgorithm</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">keyAlgorithm</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acf42abcf7fd28812960a3305d5ee9345">label</a>, byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">encryptedKey</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>.  <a href="#a7e3f51eeab08a59a587f4752d211a14c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#af7dc63e2eb864382f336e19feba57f07">WrappedKey</a> (byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ac9fa1a3a4042ea554895e3b0e4a55714">wrapAlgorithm</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">keyAlgorithm</a>, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acf42abcf7fd28812960a3305d5ee9345">label</a>, byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5d77d84786424def607cfdcf23d22a79">encryptedNonceKey</a>, byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">encryptedKey</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>.  <a href="#af7dc63e2eb864382f336e19feba57f07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaae2043d7e2d971bf0ab7b91d7dff9b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::WrappedKey" ref="acaae2043d7e2d971bf0ab7b91d7dff9b" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acaae2043d7e2d971bf0ab7b91d7dff9b">WrappedKey</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor for decoding. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332">unwrapKey</a> (Key <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332">unwrapKey</a>)  throws InvalidKeyException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76" title="Returns the key algorithm identifier, if specified.">keyAlgorithm()</a>.  <a href="#aad2af062f663f54db64f6bf78ce05332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7ff5fca1d612ec6fe7e561db6f4b28ba">unwrapKey</a> (Key <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332">unwrapKey</a>, String wrappedKeyAlgorithm)  throws InvalidKeyException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by wrappedKeyAlgorithm.  <a href="#a7ff5fca1d612ec6fe7e561db6f4b28ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a23074f627484f7211765025d3a68f7d5">setWrappingKeyIdentifier</a> (byte[] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">wrappingKeyIdentifier</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wrappingKeyIdentifier.  <a href="#a23074f627484f7211765025d3a68f7d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aafe9f7b3dc3b0251b535e94a84095fbe">setWrappingKeyIdentifier</a> (Key wrappingKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wrappingKeyIdentifier.  <a href="#aafe9f7b3dc3b0251b535e94a84095fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a37584fd035bd7ad51e92cbfdc0037f44">wrappingKeyName</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aa28d7f32a6261ceddc038048b603a249">setWrappingKeyName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrappingKeyName.  <a href="#aa28d7f32a6261ceddc038048b603a249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ac9fa1a3a4042ea554895e3b0e4a55714">wrapAlgorithm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wrapping algorithm identifier, if specified.  <a href="#ac9fa1a3a4042ea554895e3b0e4a55714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">keyAlgorithm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key algorithm identifier, if specified.  <a href="#a97e565a6373c517ab4c2a6e71fa03c76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acf42abcf7fd28812960a3305d5ee9345">label</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the label if we have one.  <a href="#acf42abcf7fd28812960a3305d5ee9345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5d77d84786424def607cfdcf23d22a79">encryptedNonceKey</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encrypted nonce key if we have one.  <a href="#a5d77d84786424def607cfdcf23d22a79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">encryptedKey</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encrypted key.  <a href="#a6c8c47adea861bf358eaeb5a47da0905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ae0a61856213e2f4a98c582a7047c6b5f">decode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a> decoder)  throws ContentDecodingException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode this object as the top-level item in a new XML document, reading it from a network buffer.  <a href="#ae0a61856213e2f4a98c582a7047c6b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7f82ad7f2174031cfb7caf0973af1ab7">encode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a> encoder)  throws ContentEncodingException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode this object during an ongoing encoding pass; this is what subclasses generally need to know how to implement.  <a href="#a7f82ad7f2174031cfb7caf0973af1ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5434f93dd12ff986185d888cfb91202c">getElementLabel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the encoder/decoder to retrieve the top-level element name programmatically.  <a href="#a5434f93dd12ff986185d888cfb91202c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7266dab03aff6c6a9ea93363b5aab7fc">validate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure all of the necessary fields are filled in prior to attempting to encode.  <a href="#a7266dab03aff6c6a9ea93363b5aab7fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7877e07e132121d03b7c92c6bc3f9bcf"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::hashCode" ref="a7877e07e132121d03b7c92c6bc3f9bcf" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>hashCode</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14feacc849c2e66a17d92878baf0a435"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::equals" ref="a14feacc849c2e66a17d92878baf0a435" args="(Object obj)" -->
boolean&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (Object obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ad96e16c8c5e9062caa762e825f0860c0">toString</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ad96e16c8c5e9062caa762e825f0860c0" title="Default toString() implementation simply prints the text encoding of the object.">toString()</a> implementation simply prints the text encoding of the object.  <a href="#ad96e16c8c5e9062caa762e825f0860c0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html">WrappedKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a401bd54cbf2f76a23adbcca9122d3395">wrapKey</a> (Key keyToBeWrapped, String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">keyAlgorithm</a>, String keyLabel, Key wrappingKey)  throws InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a {symmetric, private} key in another {symmetric, public} key, using standard wrap algorithm.  <a href="#a401bd54cbf2f76a23adbcca9122d3395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a13e5c40b07169634613916a9d9c4eb34">wrappingKeyIdentifier</a> (Key wrappingKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the wrappingKeyIdentifier corresponding to this key.  <a href="#a13e5c40b07169634613916a9d9c4eb34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa391ce7f4f32dd9fcaf806355ecde07"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::getCipherType" ref="aaa391ce7f4f32dd9fcaf806355ecde07" args="(String cipherAlgorithm)" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><b>getCipherType</b> (String cipherAlgorithm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ab28e2e11b8f4e275a041d59fded01004">wrapAlgorithmForKey</a> (String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">keyAlgorithm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given wrapping key algorithm to the default wrap algorithm for using that key.  <a href="#ab28e2e11b8f4e275a041d59fded01004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf2ed2e3f56920c5b9f01afe949bdccc"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::generateNonceKey" ref="adf2ed2e3f56920c5b9f01afe949bdccc" args="()" -->
static Key&#160;</td><td class="memItemRight" valign="bottom"><b>generateNonceKey</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5ddda2cf5de508e50f431a6886f1bf2c">AESWrapWithPad</a> (Key wrappingKey, Key keyToBeWrapped)  throws InvalidKeyException, IllegalBlockSizeException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap using AES.  <a href="#a5ddda2cf5de508e50f431a6886f1bf2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a48023897bf06569f187e7139389b98a9">AESUnwrapWithPad</a> (Key unwrappingKey, String wrappedKeyAlgorithm, byte[] input, int offset, int length)  throws InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap using AES.  <a href="#a48023897bf06569f187e7139389b98a9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8057c6d48e8e8c54dbd1ed2dc64929a3"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::NONCE_KEY_ALGORITHM" ref="a8057c6d48e8e8c54dbd1ed2dc64929a3" args="" -->
static final String&#160;</td><td class="memItemRight" valign="bottom"><b>NONCE_KEY_ALGORITHM</b> = &quot;AES&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a351651bba082543d45dc8b4b2353f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::NONCE_KEY_LENGTH" ref="a12a351651bba082543d45dc8b4b2353f" args="" -->
static final int&#160;</td><td class="memItemRight" valign="bottom"><b>NONCE_KEY_LENGTH</b> = 128</td></tr>
<tr><td colspan="2"><h2><a name="pac-static-methods"></a>
Static Package Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ea75115737e1913de11a80e6b3d1d2"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::[static initializer]" ref="ac9ea75115737e1913de11a80e6b3d1d2" args="" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>[static initializer]</b></td></tr>
<tr><td colspan="2"><h2><a name="pac-attribs"></a>
Package Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0018255e521470b1d89b4ef54d2085c"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_wrappingKeyIdentifier" ref="af0018255e521470b1d89b4ef54d2085c" args="" -->
byte[]&#160;</td><td class="memItemRight" valign="bottom"><b>_wrappingKeyIdentifier</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc1319c2ee5872099cd27d9d5aa714d1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_wrappingKeyName" ref="abc1319c2ee5872099cd27d9d5aa714d1" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapping_key_name.html">WrappingKeyName</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_wrappingKeyName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ca27829cada02186937784e6fac3ef"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_wrapAlgorithm" ref="a80ca27829cada02186937784e6fac3ef" args="" -->
String&#160;</td><td class="memItemRight" valign="bottom"><b>_wrapAlgorithm</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da70cdee6de856d739266bf84b06f36"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_keyAlgorithm" ref="a3da70cdee6de856d739266bf84b06f36" args="" -->
String&#160;</td><td class="memItemRight" valign="bottom"><b>_keyAlgorithm</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948ce5ec972a08c874011ed9f19c99fe"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_label" ref="a948ce5ec972a08c874011ed9f19c99fe" args="" -->
String&#160;</td><td class="memItemRight" valign="bottom"><b>_label</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858b247d8584171c41306d80fc5af540"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_encryptedNonceKey" ref="a858b247d8584171c41306d80fc5af540" args="" -->
byte[]&#160;</td><td class="memItemRight" valign="bottom"><b>_encryptedNonceKey</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172b1c32af9a3c3e903fee546e3f3355"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::_encryptedKey" ref="a172b1c32af9a3c3e903fee546e3f3355" args="" -->
byte[]&#160;</td><td class="memItemRight" valign="bottom"><b>_encryptedKey</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A representation of wrapped (encrypted) keys for strorage in CCN. </p>
<p>These are used to transfer symmetric and private keys between users, store them for backup, do key distribution for access control, and so on. They use standard key wrapping algorithms, and try to be fairly general. You can use them to wrap almost any type of key in any other type of key (as long as the latter is capable of encryption), though use of this class with some key types or key lengths may require installation of the Java unlimited strength cryptography policy files to succeed.</p>
<p>This class automatically handles generation of interstitial nonce keys for wrapping keys of incompatible lengths -- if you want to wrap a private key in another private key, it will generate a nonce key, wrap the first key in that nonce key, and that nonce key in the second private key.</p>
<p>For now, we have a very loose definition of default -- the default wrap algorithm depends on the type of key being used to wrap; similarly the default key algorithm depends on the type of the key being wrapped. We assume that the wrapper and unwrapper usually know the type of the wrapping key, and can derive the wrapAlgorithm. The keyAlgorithm is more often necessary to determine how to decode the key once unwrapped so it is more frequently present. Both are optional.</p>
<p>If the caller does not specify a wrapping algorithm, a standards-based default is selected, see documentation for details.</p>
<p>If the caller specifies values they will be encoded on the wire and decoded on the other end; defaults will not currently be enforced automatically. This means equals behavior should be watched closely. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8a7bdec10b52b3b73a6608f4f2dfc56f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::WrappedKey" ref="a8a7bdec10b52b3b73a6608f4f2dfc56f" args="(byte[] wrappingKeyIdentifier, byte[] encryptedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a8a7bdec10b52b3b73a6608f4f2dfc56f">org.ccnx.ccn.io.content.WrappedKey.WrappedKey</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>wrappingKeyIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>encryptedKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKeyIdentifier</td><td>a byte ID for this key, usually the digest of the encoded key. </td></tr>
    <tr><td class="paramname">encryptedKey</td><td>the wrapped, encoded key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82a56fa01d0bf73c6b3cf621a676769f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::WrappedKey" ref="a82a56fa01d0bf73c6b3cf621a676769f" args="(byte[] wrappingKeyIdentifier, String label, byte[] encryptedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a8a7bdec10b52b3b73a6608f4f2dfc56f">org.ccnx.ccn.io.content.WrappedKey.WrappedKey</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>wrappingKeyIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>encryptedKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKeyIdentifier</td><td>a byte ID for this key, usually the digest of the encoded key. </td></tr>
    <tr><td class="paramname">label</td><td>a friendly name for the key. </td></tr>
    <tr><td class="paramname">encryptedKey</td><td>the wrapped, encoded key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e3f51eeab08a59a587f4752d211a14c"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::WrappedKey" ref="a7e3f51eeab08a59a587f4752d211a14c" args="(byte[] wrappingKeyIdentifier, String wrapAlgorithm, String keyAlgorithm, String label, byte[] encryptedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a8a7bdec10b52b3b73a6608f4f2dfc56f">org.ccnx.ccn.io.content.WrappedKey.WrappedKey</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>wrappingKeyIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>wrapAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>keyAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>encryptedKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKeyIdentifier</td><td>a byte ID for this key, usually the digest of the encoded key. </td></tr>
    <tr><td class="paramname">wrapAlgorithm</td><td>the algorithm used to wrap this key, if null the default wrap algorithm for the decryption key (specified to <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332" title="Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by keyAlgorithm()...">unwrapKey()</a>) is used </td></tr>
    <tr><td class="paramname">keyAlgorithm</td><td>the algorithm of the wrapped (encrypted, encoded) key. Necessary to decode the key back into a Key object as part of unwrapping. Can be specified at unwrapping time if not stored here. </td></tr>
    <tr><td class="paramname">label</td><td>a friendly name for the key. </td></tr>
    <tr><td class="paramname">encryptedKey</td><td>the wrapped, encoded key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7dc63e2eb864382f336e19feba57f07"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::WrappedKey" ref="af7dc63e2eb864382f336e19feba57f07" args="(byte[] wrappingKeyIdentifier, String wrapAlgorithm, String keyAlgorithm, String label, byte[] encryptedNonceKey, byte[] encryptedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a8a7bdec10b52b3b73a6608f4f2dfc56f">org.ccnx.ccn.io.content.WrappedKey.WrappedKey</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>wrappingKeyIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>wrapAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>keyAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>encryptedNonceKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>encryptedKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represent an already-wrapped key as a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKeyIdentifier</td><td>a byte ID for this key, usually the digest of the encoded key. </td></tr>
    <tr><td class="paramname">wrapAlgorithm</td><td>the algorithm used to wrap this key, if null the default wrap algorithm for the decryption key (specified to <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332" title="Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by keyAlgorithm()...">unwrapKey()</a>) is used </td></tr>
    <tr><td class="paramname">keyAlgorithm</td><td>the algorithm of the wrapped (encrypted, encoded) key. Necessary to decode the key back into a Key object as part of unwrapping. Can be specified at unwrapping time if not stored here. </td></tr>
    <tr><td class="paramname">label</td><td>a friendly name for the key. </td></tr>
    <tr><td class="paramname">encryptedNonceKey</td><td>if the key is a private or public key wrapped by a public key, this defines an encrypted interposed nonce key where the nonce key is used to wrap the private or public key and the wrapping key is used to wrap the nonce key. </td></tr>
    <tr><td class="paramname">encryptedKey</td><td>the wrapped, encoded key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a48023897bf06569f187e7139389b98a9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::AESUnwrapWithPad" ref="a48023897bf06569f187e7139389b98a9" args="(Key unwrappingKey, String wrappedKeyAlgorithm, byte[] input, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Key <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a48023897bf06569f187e7139389b98a9">org.ccnx.ccn.io.content.WrappedKey.AESUnwrapWithPad</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>unwrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>wrappedKeyAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws InvalidKeyException <code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap using AES. </p>
<p>Do not use standard Cipher interface, as we need to use an alternate algorithm (see AESWrapWithPadEngine) that is not currently included in any signed provider. Once it is, we will drop this special-case code. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">unwrappingKey</td><td>key to use to decrypt </td></tr>
    <tr><td class="paramname">wrappedKeyAlgorithm</td><td>algorithm to use to decode key once decrypted. </td></tr>
    <tr><td class="paramname">input</td><td>encrypted key to decrypt and decode </td></tr>
    <tr><td class="paramname">offset</td><td>offset into encrypted data buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of data to decrypt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>decrypted, decoded key. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ddda2cf5de508e50f431a6886f1bf2c"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::AESWrapWithPad" ref="a5ddda2cf5de508e50f431a6886f1bf2c" args="(Key wrappingKey, Key keyToBeWrapped)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5ddda2cf5de508e50f431a6886f1bf2c">org.ccnx.ccn.io.content.WrappedKey.AESWrapWithPad</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>wrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>keyToBeWrapped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws InvalidKeyException, IllegalBlockSizeException <code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrap using AES. </p>
<p>Do not use standard Cipher interface, as we need to use an alternate algorithm (see AESWrapWithPadEngine) that is not currently included in any signed provider. Once it is, we will drop this special-case code. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKey</td><td>key to use to encrypt </td></tr>
    <tr><td class="paramname">keyToBeWrapped</td><td>key to encrypt </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>encrypted key. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalBlockSizeException</td><td></td></tr>
    <tr><td class="paramname">InvalidKeyException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0a61856213e2f4a98c582a7047c6b5f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::decode" ref="ae0a61856213e2f4a98c582a7047c6b5f" args="(XMLDecoder decoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ae0a61856213e2f4a98c582a7047c6b5f">org.ccnx.ccn.io.content.WrappedKey.decode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a>&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a> <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode this object as the top-level item in a new XML document, reading it from a network buffer. </p>
<p>Reads document start and end. Assumes default encoding. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></td><td>if there is an error decoding the content Decode this object as the top-level item in a new XML document, reading it from a network buffer. Reads document start and end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>input stream to read from </td></tr>
    <tr><td class="paramname">codec</td><td>the codec to use; must be recognized by XMLCodecFactory </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></td><td>if there is an error decoding the content</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>XMLCodecFactory Decode this object during an ongoing decoding pass; this is what subclasses generally need to know how to implement. Reads just the object itself, higher-level processes have handled start and end document if need be. Allows object to be read using the same code whether it is a top-level element written alone, or nested inside another element. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>the decoder being used; encapsulates state including the codec being used as well as the input source and current offset </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#a2742f46432cfddb297c88300b3b93ebd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div>
<a class="anchor" id="a7f82ad7f2174031cfb7caf0973af1ab7"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::encode" ref="a7f82ad7f2174031cfb7caf0973af1ab7" args="(XMLEncoder encoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7f82ad7f2174031cfb7caf0973af1ab7">org.ccnx.ccn.io.content.WrappedKey.encode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a>&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a> <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode this object during an ongoing encoding pass; this is what subclasses generally need to know how to implement. </p>
<p>Writes just the object itself, higher-level processes have handled start and end document if need be. Allows object to be written using the same code whether it is a top-level element written alone, or nested inside another element. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>the encoder being used; encapsulates state including the codec being used as well as the output destination and current offset </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#aeb997279d10d18277cab484de7edf741">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div>
<a class="anchor" id="a6c8c47adea861bf358eaeb5a47da0905"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::encryptedKey" ref="a6c8c47adea861bf358eaeb5a47da0905" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6c8c47adea861bf358eaeb5a47da0905">org.ccnx.ccn.io.content.WrappedKey.encryptedKey</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the encrypted key. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the encrypted key </dd></dl>

</div>
</div>
<a class="anchor" id="a5d77d84786424def607cfdcf23d22a79"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::encryptedNonceKey" ref="a5d77d84786424def607cfdcf23d22a79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5d77d84786424def607cfdcf23d22a79">org.ccnx.ccn.io.content.WrappedKey.encryptedNonceKey</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the encrypted nonce key if we have one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the encryptedNonceKey, if one is present </dd></dl>

</div>
</div>
<a class="anchor" id="a5434f93dd12ff986185d888cfb91202c"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::getElementLabel" ref="a5434f93dd12ff986185d888cfb91202c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a5434f93dd12ff986185d888cfb91202c">org.ccnx.ccn.io.content.WrappedKey.getElementLabel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allow the encoder/decoder to retrieve the top-level element name programmatically. </p>
<p>This allows subclasses to rename elements without changing their encoder/decoders. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element label to use, as a key in a loaded encoding dictionary </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#a643e91ecff8b7ed820063e7537e23acd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div>
<a class="anchor" id="a97e565a6373c517ab4c2a6e71fa03c76"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::keyAlgorithm" ref="a97e565a6373c517ab4c2a6e71fa03c76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76">org.ccnx.ccn.io.content.WrappedKey.keyAlgorithm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the key algorithm identifier, if specified. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the key algorithm </dd></dl>

</div>
</div>
<a class="anchor" id="acf42abcf7fd28812960a3305d5ee9345"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::label" ref="acf42abcf7fd28812960a3305d5ee9345" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#acf42abcf7fd28812960a3305d5ee9345">org.ccnx.ccn.io.content.WrappedKey.label</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the label if we have one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the label </dd></dl>

</div>
</div>
<a class="anchor" id="a23074f627484f7211765025d3a68f7d5"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::setWrappingKeyIdentifier" ref="a23074f627484f7211765025d3a68f7d5" args="(byte[] wrappingKeyIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a23074f627484f7211765025d3a68f7d5">org.ccnx.ccn.io.content.WrappedKey.setWrappingKeyIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>wrappingKeyIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the wrappingKeyIdentifier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKeyIdentifier</td><td>new identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafe9f7b3dc3b0251b535e94a84095fbe"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::setWrappingKeyIdentifier" ref="aafe9f7b3dc3b0251b535e94a84095fbe" args="(Key wrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a23074f627484f7211765025d3a68f7d5">org.ccnx.ccn.io.content.WrappedKey.setWrappingKeyIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>wrappingKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the wrappingKeyIdentifier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKey</td><td>key from which to generate the new identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa28d7f32a6261ceddc038048b603a249"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::setWrappingKeyName" ref="aa28d7f32a6261ceddc038048b603a249" args="(ContentName keyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aa28d7f32a6261ceddc038048b603a249">org.ccnx.ccn.io.content.WrappedKey.setWrappingKeyName</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&#160;</td>
          <td class="paramname"><em>keyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the wrappingKeyName. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyName</td><td>the new name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad96e16c8c5e9062caa762e825f0860c0"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::toString" ref="ad96e16c8c5e9062caa762e825f0860c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ad96e16c8c5e9062caa762e825f0860c0">org.ccnx.ccn.io.content.WrappedKey.toString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ad96e16c8c5e9062caa762e825f0860c0" title="Default toString() implementation simply prints the text encoding of the object.">toString()</a> implementation simply prints the text encoding of the object. </p>
<p>This demonstrates how to force use of the text encoding. </p>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#a00d055c850c6ad0a48f5e3cdbe8e22b5">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div>
<a class="anchor" id="aad2af062f663f54db64f6bf78ce05332"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::unwrapKey" ref="aad2af062f663f54db64f6bf78ce05332" args="(Key unwrapKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332">org.ccnx.ccn.io.content.WrappedKey.unwrapKey</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>unwrapKey</em></td><td>)</td>
          <td>  throws InvalidKeyException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a97e565a6373c517ab4c2a6e71fa03c76" title="Returns the key algorithm identifier, if specified.">keyAlgorithm()</a>. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7ff5fca1d612ec6fe7e561db6f4b28ba" title="Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by wrappedKeyAlgor...">unwrapKey(Key, String)</a> for details. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NoSuchAlgorithmException</td><td></td></tr>
    <tr><td class="paramname">@see</td><td><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7ff5fca1d612ec6fe7e561db6f4b28ba" title="Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by wrappedKeyAlgor...">unwrapKey(Key, String)</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ff5fca1d612ec6fe7e561db6f4b28ba"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::unwrapKey" ref="a7ff5fca1d612ec6fe7e561db6f4b28ba" args="(Key unwrapKey, String wrappedKeyAlgorithm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aad2af062f663f54db64f6bf78ce05332">org.ccnx.ccn.io.content.WrappedKey.unwrapKey</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>unwrapKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>wrappedKeyAlgorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws InvalidKeyException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwraps an encrypted key, and decodes it into a Key of an algorithm type specified by wrappedKeyAlgorithm. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">unwrapKey</td><td>the key to use to decrypt this wrapped key. </td></tr>
    <tr><td class="paramname">wrappedKeyAlgorithm</td><td>the algorithm of the wrapped key, used in decoding it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decrypted key if successful. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidKeyException</td><td>if we encounter an error using the unwrapKey to decrypt. </td></tr>
    <tr><td class="paramname">NoSuchAlgorithmException</td><td>if we do not recognize the wrappedKeyAlgorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7266dab03aff6c6a9ea93363b5aab7fc"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::validate" ref="a7266dab03aff6c6a9ea93363b5aab7fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7266dab03aff6c6a9ea93363b5aab7fc">org.ccnx.ccn.io.content.WrappedKey.validate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sure all of the necessary fields are filled in prior to attempting to encode. </p>
<p>All implementations of <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a7f82ad7f2174031cfb7caf0973af1ab7" title="Encode this object during an ongoing encoding pass; this is what subclasses generally need to know ho...">encode(XMLEncoder)</a> should call this for their classes prior to encoding. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if object is valid and can be encoded, false if there is a problem; for example mandatory fields are uninitialized </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#a0cc2a6cf56f0853fa0ab1c514b65e6b6">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div>
<a class="anchor" id="ac9fa1a3a4042ea554895e3b0e4a55714"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrapAlgorithm" ref="ac9fa1a3a4042ea554895e3b0e4a55714" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ac9fa1a3a4042ea554895e3b0e4a55714">org.ccnx.ccn.io.content.WrappedKey.wrapAlgorithm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapping algorithm identifier, if specified. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the wrap algorithm </dd></dl>

</div>
</div>
<a class="anchor" id="ab28e2e11b8f4e275a041d59fded01004"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrapAlgorithmForKey" ref="ab28e2e11b8f4e275a041d59fded01004" args="(String keyAlgorithm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#ab28e2e11b8f4e275a041d59fded01004">org.ccnx.ccn.io.content.WrappedKey.wrapAlgorithmForKey</a> </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>keyAlgorithm</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a given wrapping key algorithm to the default wrap algorithm for using that key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyAlgorithm</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a401bd54cbf2f76a23adbcca9122d3395"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrapKey" ref="a401bd54cbf2f76a23adbcca9122d3395" args="(Key keyToBeWrapped, String keyAlgorithm, String keyLabel, Key wrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html">WrappedKey</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a401bd54cbf2f76a23adbcca9122d3395">org.ccnx.ccn.io.content.WrappedKey.wrapKey</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>keyToBeWrapped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>keyAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>keyLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>wrappingKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throws InvalidKeyException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps a {symmetric, private} key in another {symmetric, public} key, using standard wrap algorithm. </p>
<p>Does not include an identifier of the wrapping key; that can be added if necessary using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#aafe9f7b3dc3b0251b535e94a84095fbe" title="Sets the wrappingKeyIdentifier.">setWrappingKeyIdentifier(Key)</a>. Default wrap algorithm if wrapping key is AES is AESWrap (RFC3394, NIST standard); this is available in Java 1.6, or BouncyCastle.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyToBeWrapped</td><td>The key to wrap, can be symmetric, private, or public. </td></tr>
    <tr><td class="paramname">keyAlgorithm</td><td>optional algorithm to associate with the wrapped key; if null we use key.getAlgorithm(). </td></tr>
    <tr><td class="paramname">keyLabel</td><td>a friendly name for the key. </td></tr>
    <tr><td class="paramname">wrappingKey</td><td>The key to use for wrapping. This can be a symmetric key or a public key (as noted above, some public key algorithms may require Java's unlimited strength policy files). If the wrapping key is a public key, and the wrapped key is a private key (which may extend past the block length of the public key) we will automatically generate a nonce (random) AES key, wrap the private key in that, and then wrap that nonce key in the public key. We derive the wrapping algorithm to use as a function of this key's algorithm. Eventually may want to allow it to be passed in (merely encrypting with the key as usual may not be the best key wrap algorithm; keys are high entropy and often require specialized padding schemes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NoSuchPaddingException</td><td></td></tr>
    <tr><td class="paramname">NoSuchAlgorithmException</td><td></td></tr>
    <tr><td class="paramname">InvalidKeyException</td><td></td></tr>
    <tr><td class="paramname">IllegalBlockSizeException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e98c395b240cc2a3aaaf86c3b10b409"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrappingKeyIdentifier" ref="a6e98c395b240cc2a3aaaf86c3b10b409" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">org.ccnx.ccn.io.content.WrappedKey.wrappingKeyIdentifier</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the wrappingKeyIdentfier for this object </dd></dl>

</div>
</div>
<a class="anchor" id="a13e5c40b07169634613916a9d9c4eb34"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrappingKeyIdentifier" ref="a13e5c40b07169634613916a9d9c4eb34" args="(Key wrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a6e98c395b240cc2a3aaaf86c3b10b409">org.ccnx.ccn.io.content.WrappedKey.wrappingKeyIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>wrappingKey</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the wrappingKeyIdentifier corresponding to this key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappingKey</td><td>the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the identifier </dd></dl>

</div>
</div>
<a class="anchor" id="a37584fd035bd7ad51e92cbfdc0037f44"></a><!-- doxytag: member="org::ccnx::ccn::io::content::WrappedKey::wrappingKeyName" ref="a37584fd035bd7ad51e92cbfdc0037f44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html#a37584fd035bd7ad51e92cbfdc0037f44">org.ccnx.ccn.io.content.WrappedKey.wrappingKeyName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the wrappingKeyName if specified </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/org/ccnx/ccn/io/content/WrappedKey.java</li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>org</b>      </li>
      <li class="navelem"><b>ccnx</b>      </li>
      <li class="navelem"><b>ccn</b>      </li>
      <li class="navelem"><b>io</b>      </li>
      <li class="navelem"><b>content</b>      </li>
      <li class="navelem"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html">WrappedKey</a>      </li>

    <li class="footer">Generated on Tue Apr 1 2014 10:51:29 for Content-Centric Networking in Java by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
